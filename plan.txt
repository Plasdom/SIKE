Done
- Add to setup.py: download atomic data from Zenodo and put somewhere sensible
- Finish sorting docstrings and type hints in transition.py (got up to ExTrans, next one to do is IzTrans)
- Get rid of types in docstrings
- Fix the Maxwellian/kinetic variable names, seems a janky way to do it and must be a better approach. Could just provide Maxwellian as input option and change how rates are calculated? In the interest of separation of concerns, difference between Maxwellian/kinetic densities is a question for analysis so both sets don't need to be stored by solver 
- Use xarrays for output
- Make better names for each module
- Get a minimal working example (will need to do pip install -e SIKE first)
- Do docstrings and type hints in other files (just need to do post_processing and plotting)
- Decide whether/how we're going to handle impurity transport (we're not)
- Decide whether/how we're going to handle sources/sinks (we're not)
- Remove petsc4py and MPI references
- Remove dependency on aurora
- Remove option to handle multiple impurities (each run should be associated with a single set of atomic data)
- Check setup.py works now you've moved it up a directory
- Finish redistributing some of the tools functions into other modules so total number of modules can be reduced (e.g. physics_tools, matrix_utils)
- Work out how to deal with atomic data
- Switch from ICL to personal repo
- Decide where things like calc_eff_rate_mats should go - in particular, how to deal with the question of full vs. partial rate equations (i.e. full set vs. Greenland-style)

To do
- Update "run" method to separate "solve" and "evolve" methods:
    - Coupling may require adding a specific dt to evolve solution forward by some total time, as opposed to setting dt and max_timesteps. Also, I don't think timestep should matter for thids problem. Could try jumping the whole timestep, then if something goes wrong try several smaller timesteps, etc
    - Add small diagonal (~1e-10?) to matrix before inversion when calling solve to improve stability? Could not do initially, then check for negative densities, non conservation  etc and warn the user you're doing it
- Handle different velocity grids provided at input
- Mangle/hide names of methods, classes etc we don't want to expose
- Expose an "update_fe" method. This can be used to recompute Maxwellian/kinetic equilibria without having to read in the atomic data again, and will be useful during coupling runs
- Should accept xarrays as input (e.g. fe from remkit?)
- Tests
- Remove any old or unused code. E.g. there's some overlap between core.py, analysis.py and post_processing.py
- Some demo scripts
- License
- Merge with main branch
- Readme:
    - Include a "Quickstart" section
    - Description of atomic data setup should provide a backup option to download and extract the data from Zenodo manually
- Sphinx documentation
- Test on a Windows and Linux machine, ask others (non-local group) to test it, etc
- Provide a config file API as well as/instead of python API to launch simulations
- See if you can relax the version requirements in the dependencies, as this may cause some issues
- Create a json schema for atomic states, transitions and (maybe) input files
- Make repo public once license has been sorted
- Simpler parallelisation, perhaps with mpi4py. Add as an OPTIONAL dependency (see e.g. uetools for optional dependency example)
- Generate n-resolved data for Hydrogen, Helium, Lithium, Beryllium, Boron, Oxygen, Nitrogen
