import pytest
import numpy as np
import xarray as xr

import sike
import sike.plasma_utils
import sike.post_processing as spp
import sike.post_processing


def test_solve():
    """Test a simple hydrogen example using the solve() method"""
    nx = 3
    Te = np.linspace(1, 5, nx)
    ne = 1e22 * np.ones(nx)

    c = sike.SIKERun(Te=Te, ne=ne, element="H")
    ds = c.solve()

    assert isinstance(ds, xr.Dataset)

    Zavg = spp.get_Zavg(ds)
    assert isinstance(ds, xr.Dataset)

    expected_vals = [0.129, 0.996, 0.998]
    assert all(np.isclose(Zavg.values, expected_vals, atol=1e-3))


def test_evolve():
    """Test a simple hydrogen example using the solve() method"""
    nx = 2
    Te = np.linspace(1, 10, nx)
    ne = 1e20 * np.ones(nx)

    for el in ["He", "C", "Ar"]:
        c = sike.SIKERun(Te=Te, ne=ne, element=el, saha_boltzmann_init=False)
        ds = c.evolve(0.0)
        Zavg_0 = spp.get_Zavg(ds)
        assert all(np.isclose(Zavg_0, 0))

        ds_evolve = c.evolve(1e3)
        ds_solve = c.solve()
        assert all(np.isclose(spp.get_Zavg(ds_evolve), spp.get_Zavg(ds_solve)))


def test_saha_boltzmann_init():
    """Ensure the Saha-Boltzmann initialisation does not evolve in time when radiative transitions are turned off"""
    nx = 2
    Te = np.linspace(1, 10, nx)
    ne = 1e20 * np.ones(nx)
    E_min_ev = 1e-4
    E_max_ev = 3e5
    vgrid, Egrid = sike.plasma_utils.generate_vgrid()
    for el in sike.SYMBOL2ELEMENT.keys():
        c = sike.SIKERun(
            Te=Te,
            ne=ne,
            vgrid=vgrid,
            element=el,
            saha_boltzmann_init=True,
            emission=False,
            radiative_recombination=False,
            autoionization=False,
        )
        ds_0 = c.evolve(0)
        ds_1 = c.evolve(1e3)
        Zavg_0 = spp.get_Zavg(ds_0)
        Zavg_1 = spp.get_Zavg(ds_1)
        assert all(np.isclose(Zavg_0, Zavg_1, atol=1e-1, rtol=1e-2))


def test_all_elements_n_resolved():
    """Ensure SIKERun object can be created for all species using n-resolved data"""
    nx = 2
    Te = np.linspace(1, 10, nx)
    ne = 1e20 * np.ones(nx)
    vgrid, _ = sike.generate_vgrid(nv=2)
    for el in sike.SYMBOL2ELEMENT.keys():
        c = sike.SIKERun(Te=Te, ne=ne, resolve_l=False, resolve_j=False, element=el)


def test_init_methods():
    """Check that the methods init_from_dist() and init_from_profiles() result in the same output when distributions are generated the same way"""
    nx = 10
    Te = np.logspace(-1, 4, nx)
    ne = 1e20 * np.ones(nx)
    elements = ["H", "C", "Ne"]

    for el in elements:
        # Initialise using Te and ne profiles
        c_pr = sike.SIKERun(Te=Te, ne=ne, element=el)
        ds_pr = c_pr.evolve(dt_s=1e6)

        # Generate equivalent Maxwellians and check they're the same as generated by SIKERun object
        fe = sike.get_maxwellians(ne=ne, Te=Te, Egrid=c_pr.Egrid, normalised=False)
        assert np.isclose(c_pr.fe * c_pr.fe_norm, fe).all()

        c_d = sike.SIKERun(fe=fe, element=el)
        ds_d = c_d.evolve(dt_s=1e6)
        assert np.isclose(c_d.Te, Te / c_d.T_norm, atol=1e-2, rtol=1e-4).all()
        assert np.isclose(c_d.ne, ne / c_d.n_norm, atol=1e-2, rtol=1e-4).all()

        nz_d = sike.post_processing.get_nz(ds_d).values
        nz_pr = sike.post_processing.get_nz(ds_pr).values
        nz_pr = np.where(nz_d / c_d.n_norm < 1e-14, 0.0, nz_pr)
        nz_d = np.where(nz_d / c_d.n_norm < 1e-14, 0.0, nz_d)

        assert np.isclose(
            nz_d / c_d.n_norm,
            nz_pr / c_pr.n_norm,
            atol=1e-1,
            rtol=1e-3,
        ).all()


def test_update_profiles():
    """Test the update_profiles() method with new Te, ne profiles in SIKE.core"""
    # Initialise the initial and final plasma profiles
    nx = 4
    Te_i = np.logspace(-1, 3, nx)
    ne_i = 1e20 * np.ones(nx)
    Te_f = 10 * Te_i
    ne_f = 1e20 * np.ones(nx)
    elements = ["Li", "C"]

    for el in elements:
        # Initialise using Te and ne profiles
        c = sike.SIKERun(Te=Te_i, ne=ne_i, element=el)
        ds_i = c.evolve(dt_s=1e6)
        Zavg_i = spp.get_Zavg(ds_i)

        # Update profiles
        c.update_profiles(Te=Te_f, ne=ne_f)

        # Iterate solution for small timesteps, confirming that mean charge state is increasing
        for i in range(10):
            ds_new = c.evolve(dt_s=1e-4)
            Zavg_new = spp.get_Zavg(ds_new)
            assert np.all(Zavg_new.values > Zavg_i.values)


def test_update_distributions():
    """Test the update_profiles() method with new distributions in SIKE.core"""
    # Initialise the initial and final plasma profiles
    nx = 4
    Te_i = np.logspace(-1, 3, nx)
    ne_i = 1e20 * np.ones(nx)
    fe_i = sike.get_maxwellians(ne=ne_i, Te=Te_i, normalised=False)
    Te_f = 10 * Te_i
    ne_f = 1e20 * np.ones(nx)
    fe_f = sike.get_maxwellians(ne=ne_f, Te=Te_f, normalised=False)
    elements = ["Li", "C"]

    for el in elements:
        # Initialise using distributions
        c = sike.SIKERun(fe=fe_i, element=el)
        ds_i = c.evolve(dt_s=1e6)
        Zavg_i = spp.get_Zavg(ds_i)

        # Update distributions
        c.update_profiles(fe=fe_f)

        # Iterate solution for small timesteps, confirming that mean charge state is increasing
        for i in range(10):
            ds_new = c.evolve(dt_s=1e-4)
            Zavg_new = spp.get_Zavg(ds_new)
            assert np.all(Zavg_new.values > Zavg_i.values)
