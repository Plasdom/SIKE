import numpy as np
import pytest
import xarray as xr

import sike
import sike.plasma_utils
import sike.post_processing
import sike.post_processing as spp


def data_exists(element: str) -> bool:
    """Checks if the data files for the given element exist"""
    data_dir = (
        sike.get_test_data_dir() if element == "T" else sike.get_atomic_data_savedir()
    )
    data_dir /= sike.SYMBOL2ELEMENT.get(element)
    levels = data_dir / f"{element}_levels_n.json"
    transitions = data_dir / f"{element}_transitions_n.json"
    return levels.exists() and transitions.exists()


def check_run_test(element: str) -> None:
    """Should we run the test calling this function based on if the elemental data is available"""
    if not data_exists(element):
        if element == "T":
            pytest.skip("Could not find Testium data")
        else:
            pytest.skip(
                f"{sike.SYMBOL2ELEMENT.get(element)} data not downloaded - see README for instructions"
            )


@pytest.mark.skipif(not data_exists("T"), reason="Could not find Testium data")
def test_testium(snapshot):
    nx = 100
    Te = np.linspace(1, 10, nx)
    ne = 1e20 * np.ones(nx)

    c = sike.SIKERun(Te=Te, ne=ne, element="T")
    ds = c.evolve(dt_s=1e0)

    Zavg = spp.get_Zavg(ds)

    assert np.round(Zavg.values, 6).tolist() == snapshot


@pytest.mark.skipif(
    not data_exists("H"),
    reason="Hydrogen data not downloaded - see README for instructions",
)
def test_solve(snapshot):
    """Test a simple hydrogen example using the solve() method"""
    nx = 3
    Te = np.linspace(1, 5, nx)
    ne = 1e22 * np.ones(nx)

    c = sike.SIKERun(Te=Te, ne=ne, element="H")
    ds = c.solve()

    assert isinstance(ds, xr.Dataset)

    Zavg = spp.get_Zavg(ds)
    assert isinstance(ds, xr.Dataset)

    assert np.round(Zavg.values, 6).tolist() == snapshot


@pytest.mark.parametrize("element", ["He", "C", "Ar"])
def test_evolve(element):
    """Test some simple atoms on how the evolve() method compares to solve()"""
    check_run_test(element)

    nx = 2
    Te = np.linspace(1, 10, nx)
    ne = 1e20 * np.ones(nx)

    c = sike.SIKERun(Te=Te, ne=ne, element=element, saha_boltzmann_init=False)
    ds = c.evolve(0.0)
    Zavg_0 = spp.get_Zavg(ds)
    np.testing.assert_allclose(Zavg_0, 0)

    ds_evolve = c.evolve(1e3)
    ds_solve = c.solve()
    np.testing.assert_allclose(spp.get_Zavg(ds_evolve), spp.get_Zavg(ds_solve))


@pytest.mark.parametrize("element", sike.SYMBOL2ELEMENT.keys())
def test_saha_boltzmann_init(element):
    """Ensure the Saha-Boltzmann initialisation does not evolve in time when radiative transitions are turned off"""
    check_run_test(element)

    nx = 2
    Te = np.linspace(1, 10, nx)
    ne = 1e20 * np.ones(nx)
    vgrid, _ = sike.plasma_utils.generate_vgrid()

    c = sike.SIKERun(
        Te=Te,
        ne=ne,
        vgrid=vgrid,
        element=element,
        saha_boltzmann_init=True,
        emission=False,
        radiative_recombination=False,
        autoionization=False,
    )

    ds_0 = c.evolve(0)
    ds_1 = c.evolve(1e3)
    Zavg_0 = spp.get_Zavg(ds_0)
    Zavg_1 = spp.get_Zavg(ds_1)
    np.testing.assert_allclose(Zavg_0, Zavg_1, atol=1e-1, rtol=1e-2)


@pytest.mark.parametrize("element", sike.SYMBOL2ELEMENT.keys())
def test_all_elements_n_resolved(element):
    """Ensure SIKERun object can be created for all species using n-resolved data"""
    check_run_test(element)

    nx = 2
    Te = np.linspace(1, 10, nx)
    ne = 1e20 * np.ones(nx)
    _vgrid, _Egrid = sike.generate_vgrid(nv=2)
    sike.SIKERun(Te=Te, ne=ne, resolve_l=False, resolve_j=False, element=element)


@pytest.mark.parametrize("element", ["H", "C", "Ne"])
def test_init_methods(element):
    """Check that the methods init_from_dist() and init_from_profiles() result in the same output when distributions are generated the same way"""
    check_run_test(element)

    nx = 10
    Te = np.logspace(-1, 4, nx)
    ne = 1e20 * np.ones(nx)

    # Initialise using Te and ne profiles
    c_pr = sike.SIKERun(Te=Te, ne=ne, element=element)
    ds_pr = c_pr.evolve(dt_s=1e6)

    # Generate equivalent Maxwellians and check they're the same as generated by SIKERun object
    fe = sike.get_maxwellians(ne=ne, Te=Te, Egrid=c_pr.Egrid, normalised=False)
    np.testing.assert_allclose(c_pr.fe * c_pr.fe_norm, fe)

    c_d = sike.SIKERun(fe=fe, element=element)
    ds_d = c_d.evolve(dt_s=1e6)
    np.testing.assert_allclose(c_d.Te, Te / c_d.T_norm, atol=1e-2, rtol=1e-4)
    np.testing.assert_allclose(c_d.ne, ne / c_d.n_norm, atol=1e-2, rtol=1e-4)

    nz_d = sike.post_processing.get_nz(ds_d).values
    nz_pr = sike.post_processing.get_nz(ds_pr).values
    nz_pr = np.where(nz_d / c_d.n_norm < 1e-14, 0.0, nz_pr)
    nz_d = np.where(nz_d / c_d.n_norm < 1e-14, 0.0, nz_d)

    np.testing.assert_allclose(
        nz_d / c_d.n_norm, nz_pr / c_pr.n_norm, atol=1e-1, rtol=1e-3
    )


@pytest.mark.parametrize("element", ["Li", "C"])
def test_update_profiles(element):
    """Test the update_profiles() method with new Te, ne profiles in SIKE.core"""
    # Initialise the initial and final plasma profiles
    nx = 4
    Te_i = np.logspace(-1, 3, nx)
    ne_i = 1e20 * np.ones(nx)
    Te_f = 10 * Te_i
    ne_f = 1e20 * np.ones(nx)

    # Initialise using Te and ne profiles
    c = sike.SIKERun(Te=Te_i, ne=ne_i, element=element)
    ds_i = c.evolve(dt_s=1e6)
    Zavg_i = spp.get_Zavg(ds_i)

    # Update profiles
    c.update_profiles(Te=Te_f, ne=ne_f)

    # Iterate solution for small timesteps, confirming that mean charge state is increasing
    for _i in range(10):
        ds_new = c.evolve(dt_s=1e-4)
        Zavg_new = spp.get_Zavg(ds_new)
        assert np.all(Zavg_new.values > Zavg_i.values)


@pytest.mark.parametrize("element", ["Li", "C"])
def test_update_distributions(element):
    """Test the update_profiles() method with new distributions in SIKE.core"""
    # Initialise the initial and final plasma profiles
    nx = 4
    Te_i = np.logspace(-1, 3, nx)
    ne_i = 1e20 * np.ones(nx)
    fe_i = sike.get_maxwellians(ne=ne_i, Te=Te_i, normalised=False)
    Te_f = 10 * Te_i
    ne_f = 1e20 * np.ones(nx)
    fe_f = sike.get_maxwellians(ne=ne_f, Te=Te_f, normalised=False)

    # Initialise using distributions
    c = sike.SIKERun(fe=fe_i, element=element)
    ds_i = c.evolve(dt_s=1e6)
    Zavg_i = spp.get_Zavg(ds_i)

    # Update distributions
    c.update_profiles(fe=fe_f)

    # Iterate solution for small timesteps, confirming that mean charge state is increasing
    for _i in range(10):
        ds_new = c.evolve(dt_s=1e-4)
        Zavg_new = spp.get_Zavg(ds_new)
        assert np.all(Zavg_new.values > Zavg_i.values)
